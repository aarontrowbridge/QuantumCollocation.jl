var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#QuantumUtils","page":"Library","title":"QuantumUtils","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumUtils]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumUtils.GATES","page":"Library","title":"QuantumCollocation.QuantumUtils.GATES","text":"GATES::Dict{Symbol, Matrix{ComplexF64}}\n\nDictionary of common quantum gates.\n\nElements\n\n:I - identity, I\n:X - Pauli X, sigma_x\n:Y - Pauli Y, sigma_y\n:Z - Pauli Z, sigma_z\n:H - Hadamard, H\n:CX - controlled-X, C_X\n:XI - -i X otimes I\n:sqrtiSWAP - sqrti textSWAP\n\n\n\n\n\n","category":"constant"},{"location":"lib/#QuantumCollocation.QuantumUtils.:⊗-Tuple{AbstractVecOrMat, AbstractVecOrMat}","page":"Library","title":"QuantumCollocation.QuantumUtils.:⊗","text":"⊗(A::AbstractVecOrMat, B::AbstractVecOrMat)\n\nKronecker product of two vectors or matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.apply-Tuple{Symbol, Vector{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumUtils.apply","text":"apply(gate::Symbol, ψ::Vector{<:Number})\n\nApply a gate from the GATES dictionary to a quantum state.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.gate-Tuple{Symbol}","page":"Library","title":"QuantumCollocation.QuantumUtils.gate","text":"gate(U::Symbol)\n\nGet a gate from the GATES dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.lift-Tuple{AbstractMatrix{<:Number}, Int64, Int64}","page":"Library","title":"QuantumCollocation.QuantumUtils.lift","text":"lift(\n    U::AbstractMatrix{<:Number},\n    i::Int,\n    n::Int;\n    levels::Int=size(U, 1)\n)\n\nLift a matrix to a larger Hilbert space by placing it on the i-th qubit of a n-qubit system. I.e.,\n\nU mapsto I_1 otimes cdots otimes I_i-1 otimes U otimes I_i+1 otimes cdots otimes I_n\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.lift-Tuple{AbstractMatrix{<:Number}, Int64, Vector{Int64}}","page":"Library","title":"QuantumCollocation.QuantumUtils.lift","text":"lift(\n    op::AbstractMatrix{<:Number},\n    i::Int,\n    levels::Vector{Int}\n)\n\nLift a matrix to a larger Hilbert space by placing it on the i-th qubit of a n-qubit system. I.e.,\n\nU mapsto I_1 otimes cdots otimes I_i-1 otimes U otimes I_i+1 otimes cdots otimes I_n\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.qubit_system_state-Tuple{String}","page":"Library","title":"QuantumCollocation.QuantumUtils.qubit_system_state","text":"qubit_system_state(ket::String)\n\nGet a quantum state from a string of qubit states, e.g. \"01\" -> ket01.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumSystems","page":"Library","title":"QuantumSystems","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumSystems]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumSystems.AbstractSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.AbstractSystem","text":"AbstractSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystemNew <: AbstractSystem\n\nA struct for storing the isomorphisms of the system's drift and drive Hamiltonians, as well as the system's parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{Matrix{<:Number}, Vector{<:Matrix{<:Number}}}","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::Matrix{<:Number},\n    H_drives::Vector{Matrix{<:Number}};\n    params=Dict{Symbol, Any}(),\n    kwargs...\n)::QuantumSystem\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumSystems.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH:\n\nG(H) = widetilde- i H = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.H-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumSystems.H","text":"H(G::AbstractMatrix{<:Number})::Matrix{ComplexF64}\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.MultiModeSystem-Tuple{Int64, Int64}","page":"Library","title":"QuantumCollocation.QuantumSystems.MultiModeSystem","text":"MultiModeSystem(\n    transmon_levels::Int,\n    cavity_levels::Int;\n    χ=2π * -0.5459e-3,\n    κ=2π * 4e-6,\n    χGF=2π * -1.01540302914e-3,\n    α=-2π * 0.143,\n    n_cavities=1\n)::QuantumSystem\n\nCreate a new QuantumSystemNew object for a transmon qubit with transmon_levels levels coupled to a single cavity with cavity_levels levels.\n\nThe Hamiltonian for this system is given by\n\nhat H =\n    frackappa2 hata^ dagger hata left( hata^daggerhata-1right) +\n    2 chi dyade hata^daggerhata +\n    left(\n        epsilon_c(t) +\n        epsilon_q(t) +\n        mathrmcc\n    right)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.lie_subalgebra_dim-Tuple{Vector{<:AbstractMatrix}}","page":"Library","title":"QuantumCollocation.QuantumSystems.lie_subalgebra_dim","text":"lie_subalgebra_dim(Hs::Vector{<:AbstractMatrix})\n\nReturns the dimension of the Lie subalgebra generated by the operators in Hs.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Integrators]","category":"page"},{"location":"lib/#QuantumCollocation.Integrators.UnitaryPadeIntegrator","page":"Library","title":"QuantumCollocation.Integrators.UnitaryPadeIntegrator","text":"\n\n\n\n","category":"type"},{"location":"generated/examples/single_qubit/","page":"Single Qubit","title":"Single Qubit","text":"EditURL = \"../../../literate/examples/single_qubit.jl\"","category":"page"},{"location":"generated/examples/single_qubit/#Single-Qubit","page":"Single Qubit","title":"Single Qubit","text":"","category":"section"},{"location":"generated/examples/single_qubit/","page":"Single Qubit","title":"Single Qubit","text":"","category":"page"},{"location":"generated/examples/single_qubit/","page":"Single Qubit","title":"Single Qubit","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/quickstart.jl\"","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate U_textgoal, with a system Hamiltonian of the form,","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = H_0 + sum_i a^i(t) H_i","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"there is the UnitarySmoothPulseProblem constructor which only requires","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"the drift Hamiltonian, H_0\nthe drive Hamiltonians, qtyH_i\nthe target unitary, U_textgoal\nthe number of timesteps, T\nthe (initial) time step size, Delta t","category":"page"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart Guide","title":"Basic Usage","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For example, to create a problem for a single qubit X gate (with a bound on the drive of a^i  a_textbound), i.e., with system hamiltonian","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = fracomega2 sigma_z + a^1(t) sigma_x + a^2(t) sigma_y","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories\nusing QuantumCollocation\n\n# set time parameters\nT = 100\nΔt = 0.1\n\n# use the exported gate dictionary to get the gates we need\nσx = gate(:X)\nσy = gate(:Y)\nσz = gate(:Z)\n\n# define drift and drive Hamiltonians\nH_drift = 0.5 * σz\nH_drives = [σx, σy]\n\n# define target unitary\nU_goal = σx\n\n# set bound on the drive\na_bound = 1.0\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The above output comes from the Ipopt.jl solver. To see the final fidelity we can use the unitary_fidelity function exported by QuantumCollocation.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity: \", unitary_fidelity(prob))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily plot the solutions using the plot function exported by NamedTrajectories.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/#Minimum-Time-Problems","page":"Quickstart Guide","title":"Minimum Time Problems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"mathcalF(U_T U_textgoal) geq mathcalF_textmin","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Using the problem we just solved we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# final fidelity constraint\nfinal_fidelity = 0.99\n\n# weight on the minimum time objective\nD = 10.0\n\nprob_min_time = UnitaryMinimumTimeProblem(\n    prob;\n    final_fidelity=final_fidelity,\n    D=D\n)\n\nsolve!(prob_min_time; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can see that the final fidelity is indeed greater than the minimum fidelity we set.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity:    \", unitary_fidelity(prob_min_time))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"and that the duration of the pulse has decreased.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"initial_dur = times(prob.trajectory)[end]\nmin_time_dur = times(prob_min_time.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_dur)\nprintln(\"Minimum duration:  \", min_time_dur)\nprintln(\"Duration decrease: \", initial_dur - min_time_dur)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also plot the solutions for the minimum time problem.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob_min_time.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumCollocation","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Collocation for Quantum Optimal Control (arXiv)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In quantum optimal control, we are interested in finding a pulse sequence a_1T-1 to drive a quantum system and realize a target gate U_textgoal. We formulate this problem as a nonlinear program (NLP) of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nundersetU_1T a_1T-1textminimize  quad ell(U_T U_textgoal)\ntext subject to   quad f(U_t+1 U_t a_t) = 0 \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f defines the dynamics, implicitly, as constraints on the states and controls, U_1T and a_1T-1, which are both free variables in the solver. This optimization framework is called direct collocation.  For details of our implementation please see our award-winning paper Direct Collocation for Quantum Optimal Control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gist of the method is that the dynamics are given by the solution to the Schrodinger equation, which is results in unitary evolution given by exp(-i H(a_t)), where H(a_t) is the Hamiltonian of the system.  We can approximate this evolution using Pade approximants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nf(U_t+1 U_t a_t) = U_t+1 - exp(-i H(a_t)) U_t \napprox U_t+1 - B^-1(a_t) F(a_t) U_t \n= B(a_t) U_t+1 - F(a_t) U_t \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(a_t) and F(a_t) are the backward and forward Pade operators, and are just polynomials in H(a_t). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation is possible because direct collocation allows for the dynamics to be implicit. Since numerically calculating matrix exponentials inherently requires an approximation – the Padé approximant is commonly used – utilizing this formulation significantly improves performance, as, at least here, no matrix inversion is required.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"EditURL = \"../../../literate/man/utils.jl\"","category":"page"},{"location":"generated/man/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"generated/man/utils/#Gates","page":"Utilities","title":"Gates","text":"","category":"section"},{"location":"generated/man/utils/#States","page":"Utilities","title":"States","text":"","category":"section"},{"location":"generated/man/utils/#Operators","page":"Utilities","title":"Operators","text":"","category":"section"},{"location":"generated/man/utils/#Isomorphisms","page":"Utilities","title":"Isomorphisms","text":"","category":"section"},{"location":"generated/man/utils/#Measurements","page":"Utilities","title":"Measurements","text":"","category":"section"},{"location":"generated/man/utils/#Subspaces","page":"Utilities","title":"Subspaces","text":"","category":"section"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a QuantumControlProblem object.  The problem templates are:","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem\nUnitaryMinimumTimeProblem","category":"page"},{"location":"generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(H_drift, H_drives, U_goal, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(system::QuantumSystem, U_goal, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\nU_goal::AbstractMatrix{<:Number}: the target unitary\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nfree_time::Bool=true: whether or not to allow the time steps to vary\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\ndda_bound::Float64=1.0: the bound on the control pulse derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nΔt_min::Float64=0.5 * Δt: the minimum time step size\nΔt_max::Float64=1.5 * Δt: the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nleakage_suppression::Bool=false: whether or not to suppress leakage to higher energy states\nleakage_indices::Union{Nothing, Vector{Int}}=nothing: the indices of vectildeU corresponding leakage operators that should be suppressed\nsystem_levels::Union{Nothing, Vector{Int}}=nothing: the number of levels in each subsystem\nR_leakage=1e-1: the weight on the leakage suppression term\nmax_iter::Int=1000: the maximum number of iterations for the solver\nlinear_solver::String=\"mumps\": the linear solver to use\nipopt_options::Options=Options(): the options for the Ipopt solver\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: additional constraints to add to the problem\ntimesteps_all_equal::Bool=true: whether or not to enforce that all time steps are equal\nverbose::Bool=false: whether or not to print constructor output\nU_init::Union{AbstractMatrix{<:Number},Nothing}=nothing: an initial guess for the unitary\nintegrator=Integrators.fourth_order_pade: the integrator to use for the unitary\ngeodesic=true: whether or not to use the geodesic as the initial guess for the unitary\npade_order=4: the order of the Pade approximation to use for the unitary integrator\nautodiff=pade_order != 4: whether or not to use automatic differentiation for the unitary integrator\nsubspace=nothing: the subspace to use for the unitary integrator\njacobian_structure=true: whether or not to use the jacobian structure\nhessian_approximation=false: whether or not to use L-BFGS hessian approximation in Ipopt\nblas_multithreading=true: whether or not to use multithreading in BLAS\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/#Unitary-Minimum-Time-Problem","page":"Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}

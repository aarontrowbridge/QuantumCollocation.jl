var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"release_notes/#[v0.2.0]-2024-02-22","page":"Release Notes","title":"[v0.2.0] - 2024-02-22","text":"","category":"section"},{"location":"release_notes/#Added","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"EmbeddedOperators to handle subspace gate optimization and leakage suppression\nPlotting methods for unitary populations","category":"page"},{"location":"release_notes/#Changed","page":"Release Notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"New quantum systems interface\nTransmon system template\nRestructured the code base for easier quantum system and problem template development","category":"page"},{"location":"release_notes/#Removed","page":"Release Notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Stale examples ","category":"page"},{"location":"release_notes/#Fixed","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Robustness improvements objective test fixes ","category":"page"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"EditURL = \"../../../literate/man/losses.jl\"","category":"page"},{"location":"generated/man/losses/#Losses","page":"Losses","title":"Losses","text":"","category":"section"},{"location":"generated/man/losses/#Unitary-Losses","page":"Losses","title":"Unitary Losses","text":"","category":"section"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"Losses.isovec_unitary_fidelity","category":"page"},{"location":"generated/man/losses/#QuantumCollocation.Losses.isovec_unitary_fidelity","page":"Losses","title":"QuantumCollocation.Losses.isovec_unitary_fidelity","text":"isovec_unitary_fidelity(Ũ::AbstractVector, Ũgoal::AbstractVector)\n\nReturns the fidelity between the isomorphic unitary vecwidetildeU sim U in SU(n) and the isomorphic goal unitary vecwidetildeU_textgoal.\n\nbeginaligned\nmathcalF(vecwidetildeU vecwidetildeU_textgoal) = frac1n abstr qty(U_textgoal^dagger U) \n= frac1n sqrtT_R^2 + T_I^2\nendaligned\n\nwhere T_R = langle vecwidetildeU_textgoal R vecwidetildeU_R rangle + langle vecwidetildeU_textgoal I vecwidetildeU_I rangle and T_I = langle vecwidetildeU_textgoal R vecwidetildeU_I rangle - langle vecwidetildeU_textgoal I vecwidetildeU_R rangle.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"","category":"page"},{"location":"generated/man/losses/","page":"Losses","title":"Losses","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#QuantumUtils","page":"Library","title":"QuantumUtils","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumUtils]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumUtils.annihilate-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.create-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.kron_from_dict-Tuple{Any, Any}","page":"Library","title":"QuantumCollocation.QuantumUtils.kron_from_dict","text":"kronfromdict(keys, dict; kwargs...)\n\nReduce the keys to a single operator by using the provided dictionary and the kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.number-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumUtils.number","text":"number(levels::Int)\n\nGet the number operator n = a'a for a system with levels levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.operators_from_dict-Tuple{AbstractVector, Any}","page":"Library","title":"QuantumCollocation.QuantumUtils.operators_from_dict","text":"operatorsfromdict(keys::AbstractVector{<:Any}, operatordictionary; Ikey=:I)\n\nReplace the vector of keys using the operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.operators_from_dict-Tuple{String, Any}","page":"Library","title":"QuantumCollocation.QuantumUtils.operators_from_dict","text":"operatorsfromdict(keystring::String, operatordictionary; I_key=\"I\")\n\nReplace the string (each character is one key) with operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.quad-Tuple{Int64}","page":"Library","title":"QuantumCollocation.QuantumUtils.quad","text":"quad(levels::Int)\n\nGet the operator n(n - I) for a system with levels levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.quantum_state-Tuple{String, Vector{Int64}}","page":"Library","title":"QuantumCollocation.QuantumUtils.quantum_state","text":"quantum_state(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 2),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\nExample\n\nTODO: add example\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.vec⁻¹-Tuple{AbstractVector}","page":"Library","title":"QuantumCollocation.QuantumUtils.vec⁻¹","text":"isomporphism utilities\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumSystems","page":"Library","title":"QuantumSystems","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumSystems]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing the isomorphisms of the system's drift and drive Hamiltonians, as well as the system's parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::Matrix{<:Number},\n    H_drives::Vector{Matrix{<:Number}};\n    params=Dict{Symbol, Any}(),\n    kwargs...\n)::QuantumSystem\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystemCoupling","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystemCoupling","text":"QuantumSystemCoupling <: AbstractQuantumSystem\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumSystems.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH:\n\nG(H) = widetilde- i H = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.H-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumSystems.H","text":"H(G::AbstractMatrix{<:Number})::Matrix{ComplexF64}\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H\n\n\n\n\n\n","category":"method"},{"location":"lib/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Integrators]","category":"page"},{"location":"lib/#QuantumCollocation.Integrators.UnitaryPadeIntegrator","page":"Library","title":"QuantumCollocation.Integrators.UnitaryPadeIntegrator","text":"\n\n\n\n","category":"type"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"EditURL = \"../../../literate/examples/multilevel_transmon.jl\"","category":"page"},{"location":"generated/examples/multilevel_transmon/#Multilevel-Transmon","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"hatH(t) = -fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"where hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We will use the following parameter values:","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"beginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"For convenience, we have defined the TransmonSystem function in the QuantumSystemTemplates module, which returns a QuantumSystem object for a transmon qubit. We will use this function to define the system.","category":"page"},{"location":"generated/examples/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"To begin, let's load the necessary packages, define the system parameters, and create a a QuantumSystem object using the TransmonSystem function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"using QuantumCollocation\nusing NamedTrajectories\nusing LinearAlgebra\nusing SparseArrays\nusing Random; Random.seed!(123)\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the system parameters\nlevels = 5\nδ = 0.2\n\n# add a bound to the controls\na_bound = 0.2\n\n# create the system\nsys = TransmonSystem(levels=levels, δ=δ)\n\n# let's look at the parameters of the system\nsys.params","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Since this is a multilevel transmon and we want to implement an, let's say, X gate on the qubit subspace, i.e., the first two levels we can utilize the EmbeddedOperator type to define the target operator.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# define the target operator\nop = EmbeddedOperator(:X, sys)\n\n# show the full operator\nop.operator |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this formulation, we also use a subspace identity as the initial state, which looks like","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"get_subspace_identity(op) |> sparse","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We can then pass this embedded operator to the UnitarySmoothPulseProblem template to create","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the problem\nprob = UnitarySmoothPulseProblem(sys, op, T, Δt; a_bound=a_bound)\n\n# solve the problem\nsolve!(prob; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"println(\"Fidelity: \", unitary_fidelity(prob; subspace=op.subspace_indices))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/#Leakage-suppresion","page":"Multilevel Transmon","title":"Leakage suppresion","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"As can be seen from the above plot, there is a substantial amount of leakage into the higher levels during the evolution. To mitigate this, we have implemented the ability to add a cost to populating the leakage levels, in particular this is an L_1 norm cost, which is implemented via slack variables and should ideally drive those leakage populations down to zero. To implement this, pass leakage_suppresion=true and R_leakage={value} to the UnitarySmoothPulseProblem template.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# create the a leakage suppression problem, initializing with the previous solution\n\nprob_leakage = UnitarySmoothPulseProblem(sys, op, T, Δt;\n    a_bound=a_bound,\n    leakage_suppression=true,\n    R_leakage=1e-1,\n    a_guess=prob.trajectory.a\n)\n\n# solve the problem\n\nsolve!(prob_leakage; max_iter=50)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"println(\"Fidelity: \", unitary_fidelity(prob_leakage; subspace=op.subspace_indices))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and plot the result using the plot_unitary_populations function.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"plot_unitary_populations(prob_leakage; fig_size=(900, 700))","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Here we can see that the leakage populations have been driven substantially down.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/quickstart.jl\"","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate U_textgoal, with a system Hamiltonian of the form,","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = H_0 + sum_i a^i(t) H_i","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"there is the UnitarySmoothPulseProblem constructor which only requires","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"the drift Hamiltonian, H_0\nthe drive Hamiltonians, qtyH_i\nthe target unitary, U_textgoal\nthe number of timesteps, T\nthe (initial) time step size, Delta t","category":"page"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart Guide","title":"Basic Usage","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For example, to create a problem for a single qubit X gate (with a bound on the drive of a^i  a_textbound), i.e., with system hamiltonian","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = fracomega2 sigma_z + a^1(t) sigma_x + a^2(t) sigma_y","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories\nusing QuantumCollocation\n\n# set time parameters\nT = 100\nΔt = 0.1\n\n# use the exported gate dictionary to get the gates we need\nσx = get_gate(:X)\nσy = get_gate(:Y)\nσz = get_gate(:Z)\n\n# define drift and drive Hamiltonians\nH_drift = 0.5 * σz\nH_drives = [σx, σy]\n\n# define target unitary\nU_goal = σx\n\n# set bound on the drive\na_bound = 1.0\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The above output comes from the Ipopt.jl solver. To see the final fidelity we can use the unitary_fidelity function exported by QuantumCollocation.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity: \", unitary_fidelity(prob))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily plot the solutions using the plot function exported by NamedTrajectories.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/#Minimum-Time-Problems","page":"Quickstart Guide","title":"Minimum Time Problems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"mathcalF(U_T U_textgoal) geq mathcalF_textmin","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Using the problem we just solved we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# final fidelity constraint\nfinal_fidelity = 0.99\n\n# weight on the minimum time objective\nD = 10.0\n\nprob_min_time = UnitaryMinimumTimeProblem(\n    prob;\n    final_fidelity=final_fidelity,\n    D=D\n)\n\nsolve!(prob_min_time; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can see that the final fidelity is indeed greater than the minimum fidelity we set.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity:    \", unitary_fidelity(prob_min_time))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"and that the duration of the pulse has decreased.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"initial_dur = get_times(prob.trajectory)[end]\nmin_time_dur = get_times(prob_min_time.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_dur)\nprintln(\"Minimum duration:  \", min_time_dur)\nprintln(\"Duration decrease: \", initial_dur - min_time_dur)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also plot the solutions for the minimum time problem.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob_min_time.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumCollocation","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Collocation for Quantum Optimal Control (arXiv)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In quantum optimal control, we are interested in finding a pulse sequence a_1T-1 to drive a quantum system and realize a target gate U_textgoal. We formulate this problem as a nonlinear program (NLP) of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nundersetU_1T a_1T-1 Delta t_1T-1textminimize  quad ell(U_T U_textgoal)\ntext subject to   quad f(U_t+1 U_t a_t Delta t_t) = 0 \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f defines the dynamics, implicitly, as constraints on the states and controls, U_1T and a_1T-1, which are both free variables in the solver. This optimization framework is called direct collocation.  For details of our implementation please see our award-winning paper Direct Collocation for Quantum Optimal Control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gist of the method is that the dynamics are given by the solution to the Schrodinger equation, which results in unitary evolution given by exp(-i Delta t H(a_t)), where H(a_t) is the Hamiltonian of the system and Delta t is the timestep.  We can approximate this evolution using Pade approximants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nf(U_t+1 U_t a_t Delta t_t) = U_t+1 - exp(-i Delta t_t H(a_t)) U_t \napprox U_t+1 - B^-1(a_t Delta t_t) F(a_t Delta t_t) U_t \n= B(a_t Delta t_t) U_t+1 - F(a_t Delta t_t) U_t \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(a_t) and F(a_t) are the backward and forward Pade operators and are just polynomials in H(a_t). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation is possible because direct collocation allows for the dynamics to be implicit. Since numerically calculating matrix exponentials inherently requires an approximation – the Padé approximant is commonly used – utilizing this formulation significantly improves performance, as, at least here, no matrix inversion is required.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"EditURL = \"../../../literate/man/utils.jl\"","category":"page"},{"location":"generated/man/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"generated/man/utils/#Gates","page":"Utilities","title":"Gates","text":"","category":"section"},{"location":"generated/man/utils/#States","page":"Utilities","title":"States","text":"","category":"section"},{"location":"generated/man/utils/#Operators","page":"Utilities","title":"Operators","text":"","category":"section"},{"location":"generated/man/utils/#Isomorphisms","page":"Utilities","title":"Isomorphisms","text":"","category":"section"},{"location":"generated/man/utils/#Measurements","page":"Utilities","title":"Measurements","text":"","category":"section"},{"location":"generated/man/utils/#Subspaces","page":"Utilities","title":"Subspaces","text":"","category":"section"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a QuantumControlProblem object.  The problem templates are:","category":"page"},{"location":"generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/#Unitary-Minimum-Time-Problem","page":"Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitaryMinimumTimeProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem","text":"UnitaryMinimumTimeProblem(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem,\n    objective::Objective,\n    integrators::Vector{<:AbstractIntegrator},\n    constraints::Vector{<:AbstractConstraint};\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    prob::QuantumControlProblem;\n    kwargs...\n)\n\nUnitaryMinimumTimeProblem(\n    data_path::String;\n    kwargs...\n)\n\nCreate a minimum-time problem for unitary control.\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nJ(vectildeU a dota ddota) + D sum_t Delta t_t \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n c(vectildeU a dota ddota) = 0 \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nArguments\n\ntrajectory::NamedTrajectory: The initial trajectory.\nsystem::AbstractQuantumSystem: The quantum system.\nobjective::Objective: The objective function (additional to the minimum-time objective).\nintegrators::Vector{<:AbstractIntegrator}: The integrators.\nconstraints::Vector{<:AbstractConstraint}: The constraints.\n\nKeyword Arguments\n\nunitary_symbol::Symbol=:Ũ⃗: The symbol for the unitary control.\nfinal_fidelity::Float64=0.99: The final fidelity.\nD=1.0: The weight for the minimum-time objective.\nverbose::Bool=false: Whether to print additional information.\nipopt_options::Options=Options(): The options for the Ipopt solver.\nkwargs...: Additional keyword arguments to pass to QuantumControlProblem.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(system::QuantumSystem, operator, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\noperator::Union{EmbeddedOperator, AbstractMatrix{<:Number}}: the target unitary, either in the form of an EmbeddedOperator or a `Matrix{ComplexF64}\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nfree_time::Bool=true: whether or not to allow the time steps to vary\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\ndda_bound::Float64=1.0: the bound on the control pulse derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nΔt_min::Float64=0.5 * Δt: the minimum time step size\nΔt_max::Float64=1.5 * Δt: the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nleakage_suppression::Bool=false: whether or not to suppress leakage to higher energy states\nR_leakage=1e-1: the weight on the leakage suppression term\nmax_iter::Int=1000: the maximum number of iterations for the solver\nlinear_solver::String=\"mumps\": the linear solver to use\nipopt_options::Options=Options(): the options for the Ipopt solver\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: additional constraints to add to the problem\ntimesteps_all_equal::Bool=true: whether or not to enforce that all time steps are equal\nverbose::Bool=false: whether or not to print constructor output\nintegrator=Integrators.fourth_order_pade: the integrator to use for the unitary\ngeodesic=true: whether or not to use the geodesic as the initial guess for the unitary\npade_order=4: the order of the Pade approximation to use for the unitary integrator\nautodiff=pade_order != 4: whether or not to use automatic differentiation for the unitary integrator\nsubspace=nothing: the subspace to use for the unitary integrator\njacobian_structure=true: whether or not to use the jacobian structure\nhessian_approximation=false: whether or not to use L-BFGS hessian approximation in Ipopt\nblas_multithreading=true: whether or not to use multithreading in BLAS\n\n\n\n\n\nUnitarySmoothPulseProblem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    operator,\n    T,\n    Δt;\n    kwargs...\n)\n\nConstructor for a UnitarySmoothPulseProblem from a drift Hamiltonian and a set of control Hamiltonians.\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}

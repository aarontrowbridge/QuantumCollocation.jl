var documenterSearchIndex = {"docs":
[{"location":"lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/#QuantumUtils","page":"Library","title":"QuantumUtils","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumUtils]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumUtils.kron_from_dict-Tuple{Any, Any}","page":"Library","title":"QuantumCollocation.QuantumUtils.kron_from_dict","text":"kronfromdict(keys, dict; kwargs...)\n\nReduce the keys to a single operator by using the provided dictionary and the kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.operators_from_dict-Tuple{AbstractVector, Any}","page":"Library","title":"QuantumCollocation.QuantumUtils.operators_from_dict","text":"operatorsfromdict(keys::AbstractVector{<:Any}, operatordictionary; Ikey=:I)\n\nReplace the vector of keys using the operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.operators_from_dict-Tuple{String, Any}","page":"Library","title":"QuantumCollocation.QuantumUtils.operators_from_dict","text":"operatorsfromdict(keystring::String, operatordictionary; I_key=\"I\")\n\nReplace the string (each character is one key) with operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.subspace_unitary-Tuple{Vector{Int64}, Symbol, Union{Int64, Vector{Int64}}}","page":"Library","title":"QuantumCollocation.QuantumUtils.subspace_unitary","text":"subspace_unitary(\n    levels::Vector{Int},\n    gate_name::Symbol,\n    qubit::Union{Int, Vector{Int}}\n)\n\nGet a unitary matrix for a gate acting on a subspace of a multilevel system.\n\nTODO: reimplement this as embed_operator with more methods.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumUtils.vec⁻¹-Tuple{AbstractVector}","page":"Library","title":"QuantumCollocation.QuantumUtils.vec⁻¹","text":"isomporphism utilities\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumSystems","page":"Library","title":"QuantumSystems","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.QuantumSystems]","category":"page"},{"location":"lib/#QuantumCollocation.QuantumSystems.AbstractSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.AbstractSystem","text":"AbstractSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystemNew <: AbstractSystem\n\nA struct for storing the isomorphisms of the system's drift and drive Hamiltonians, as well as the system's parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{Matrix{<:Number}, Vector{<:Matrix{<:Number}}}","page":"Library","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::Matrix{<:Number},\n    H_drives::Vector{Matrix{<:Number}};\n    params=Dict{Symbol, Any}(),\n    kwargs...\n)::QuantumSystem\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumSystems.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH:\n\nG(H) = widetilde- i H = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.H-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"QuantumCollocation.QuantumSystems.H","text":"H(G::AbstractMatrix{<:Number})::Matrix{ComplexF64}\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocation.QuantumSystems.MultiModeSystem-Tuple{Int64, Int64}","page":"Library","title":"QuantumCollocation.QuantumSystems.MultiModeSystem","text":"MultiModeSystem(\n    transmon_levels::Int,\n    cavity_levels::Int;\n    χ=2π * -0.5459e-3,\n    κ=2π * 4e-6,\n    χGF=2π * -1.01540302914e-3,\n    α=-2π * 0.143,\n    n_cavities=1\n)::QuantumSystem\n\nCreate a new QuantumSystemNew object for a transmon qubit with transmon_levels levels coupled to a single cavity with cavity_levels levels.\n\nThe Hamiltonian for this system is given by\n\nhat H =\n    frackappa2 hata^ dagger hata left( hata^daggerhata-1right) +\n    2 chi dyade hata^daggerhata +\n    left(\n        epsilon_c(t) +\n        epsilon_q(t) +\n        mathrmcc\n    right)\n\n\n\n\n\n","category":"method"},{"location":"lib/#Integrators","page":"Library","title":"Integrators","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [QuantumCollocation.Integrators]","category":"page"},{"location":"lib/#QuantumCollocation.Integrators.UnitaryPadeIntegrator","page":"Library","title":"QuantumCollocation.Integrators.UnitaryPadeIntegrator","text":"\n\n\n\n","category":"type"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"EditURL = \"../../../literate/examples/multilevel_transmon.jl\"","category":"page"},{"location":"generated/examples/multilevel_transmon/#Multilevel-Transmon","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"In this example we will look at a multilevel transmon qubit with a Hamiltonian given by","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"hatH(t) = fracdelta2 hatn(hatn - 1) + u_1(t) (hata + hata^dagger) + u_2(t) i (hata - hata^dagger)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"where hatn = hata^dagger hata is the number operator, hata is the annihilation operator, delta is the anharmonicity, and u_1(t) and u_2(t) are control fields.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We will use the following parameter values:","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"beginaligned\ndelta = 02 text GHz\nabsu_i(t) leq 02 text GHz\nT_0 = 10 text ns\nendaligned","category":"page"},{"location":"generated/examples/multilevel_transmon/#Setting-up-the-problem","page":"Multilevel Transmon","title":"Setting up the problem","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"using QuantumCollocation\nusing NamedTrajectories\nusing LinearAlgebra\n\n# define the time parameters\n\nT₀ = 10     # total time in ns\nT = 50      # number of time steps\nΔt = T₀ / T # time step\n\n# define the number of levels to model\nlevels = 3\n\n# create operators\nn̂ = number(levels)\nâ = annihilate(levels)\nâ_dag = create(levels)\n\n# define the Hamiltonian\nδ = 0.2\nH_drift = 2π * δ * n̂ * (n̂ - I(levels)) / 2\nH_drives = [\n    2π * (â + â_dag),\n    2π * im * (â - â_dag),\n]\n\n# define the goal unitary in the computational subspace\nU_init, U_goal = subspace_unitary([levels], :X, 1)\n\nU_goal","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Let's get the subspace indices as well as we will need them later.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"subspace = subspace_indices([levels])\n\n# check that these are the correct indices (trivial in the case of a single transmon, but a useful check for more complicated systems)\nU_goal[subspace, subspace]","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"WE also can look at U_init, which is not exactly the identity","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"U_init","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"Now will set up the optimization problem using the UnitarySmoothPulseProblem type.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# set the bound on the pulse amplitude\n\na_bound = 2π * 0.2\n\nprob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    Δt;\n    U_init=U_init,\n    subspace=subspace,\n    a_bound=a_bound\n)\n\n# and we can solve this problem\n\nsolve!(prob; max_iter=100)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"and we can look at the fidelity in the subspace","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"f = unitary_fidelity(prob; subspace=subspace)\n\nprintln(\"Fidelity: $f\")","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"We can also look at the pulse shapes","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"transformations = OrderedDict(\n    :Ũ⃗ => [\n        x -> populations(iso_vec_to_operator(x)[:, 1]),\n        x -> populations(iso_vec_to_operator(x)[:, 2]),\n    ]\n)\n\ntransforamtion_labels = OrderedDict(\n    :Ũ⃗ => [\n        \"\\\\psi^g\",\n        \"\\\\psi^e\",\n    ]\n)\n\ntransformation_titles = OrderedDict(\n    :Ũ⃗ => [\n        \"Populations of evolution from |0⟩\",\n        \"Populations of evolution from |1⟩\",\n    ]\n)\n\nplot(prob.trajectory, [:a];\n    res=(1200, 1200),\n    transformations=transformations,\n    transformation_labels=transforamtion_labels,\n    include_transformation_labels=true,\n    transformation_titles=transformation_titles\n)","category":"page"},{"location":"generated/examples/multilevel_transmon/#Leakage-suppression","page":"Multilevel Transmon","title":"Leakage suppression","text":"","category":"section"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"As can bee seen in the plot above, although the fidelity is high, the f level of the transmon is highly populated throughout the evolution. This is suboptimal, but we can account for this by penalizing the leakage elements of the unitary, namely those elements of the form U_f i where i neq f.  We utilize an L_1 penalty on these elements, which is implemented in the UnitarySmoothPulseProblem type as the leakage_penalty keyword argument.","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"# get the indices of the leakage subspace of the isomorphic vector representation\n# of the unitary\nleakage_indices = subspace_leakage_indices(levels)\n\n# set the leakage penalty\nR_leakage = 1.0e0\n\nnew_prob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    timesteps(prob.trajectory)[end];\n    U_init=U_init,\n    subspace=subspace,\n    a_guess=prob.trajectory.a,\n    a_bound=a_bound,\n    leakage_suppression=true,\n    leakage_indices=leakage_indices,\n    system_levels=[levels],\n    R_leakage=R_leakage,\n)\n\nsolve!(new_prob; max_iter=100)","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"","category":"page"},{"location":"generated/examples/multilevel_transmon/","page":"Multilevel Transmon","title":"Multilevel Transmon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/quickstart.jl\"","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To set up and solve a quantum optimal control problems we provide high level problem templates to quickly get started. For unitary gate problems, where we want to realize a gate U_textgoal, with a system Hamiltonian of the form,","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = H_0 + sum_i a^i(t) H_i","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"there is the UnitarySmoothPulseProblem constructor which only requires","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"the drift Hamiltonian, H_0\nthe drive Hamiltonians, qtyH_i\nthe target unitary, U_textgoal\nthe number of timesteps, T\nthe (initial) time step size, Delta t","category":"page"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart Guide","title":"Basic Usage","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"For example, to create a problem for a single qubit X gate (with a bound on the drive of a^i  a_textbound), i.e., with system hamiltonian","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"H(t) = fracomega2 sigma_z + a^1(t) sigma_x + a^2(t) sigma_y","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using NamedTrajectories\nusing QuantumCollocation\n\n# set time parameters\nT = 100\nΔt = 0.1\n\n# use the exported gate dictionary to get the gates we need\nσx = gate(:X)\nσy = gate(:Y)\nσz = gate(:Z)\n\n# define drift and drive Hamiltonians\nH_drift = 0.5 * σz\nH_drives = [σx, σy]\n\n# define target unitary\nU_goal = σx\n\n# set bound on the drive\na_bound = 1.0\n\n# build the problem\nprob = UnitarySmoothPulseProblem(\n    H_drift,\n    H_drives,\n    U_goal,\n    T,\n    Δt;\n    a_bound=a_bound,\n)\n\n# solve the problem\nsolve!(prob; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The above output comes from the Ipopt.jl solver. To see the final fidelity we can use the unitary_fidelity function exported by QuantumCollocation.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity: \", unitary_fidelity(prob))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily plot the solutions using the plot function exported by NamedTrajectories.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/#Minimum-Time-Problems","page":"Quickstart Guide","title":"Minimum Time Problems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also easily set up and solve a minimum time problem, where we enforce a constraint on the final fidelity:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"mathcalF(U_T U_textgoal) geq mathcalF_textmin","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Using the problem we just solved we can do the following:","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# final fidelity constraint\nfinal_fidelity = 0.99\n\n# weight on the minimum time objective\nD = 10.0\n\nprob_min_time = UnitaryMinimumTimeProblem(\n    prob;\n    final_fidelity=final_fidelity,\n    D=D\n)\n\nsolve!(prob_min_time; max_iter=30)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can see that the final fidelity is indeed greater than the minimum fidelity we set.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"println(\"Final fidelity:    \", unitary_fidelity(prob_min_time))","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"and that the duration of the pulse has decreased.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"initial_dur = times(prob.trajectory)[end]\nmin_time_dur = times(prob_min_time.trajectory)[end]\n\nprintln(\"Initial duration:  \", initial_dur)\nprintln(\"Minimum duration:  \", min_time_dur)\nprintln(\"Duration decrease: \", initial_dur - min_time_dur)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can also plot the solutions for the minimum time problem.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"plot(prob_min_time.trajectory, [:Ũ⃗, :a])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumCollocation","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Collocation for Quantum Optimal Control (arXiv)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In quantum optimal control, we are interested in finding a pulse sequence a_1T-1 to drive a quantum system and realize a target gate U_textgoal. We formulate this problem as a nonlinear program (NLP) of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nundersetU_1T a_1T-1textminimize  quad ell(U_T U_textgoal)\ntext subject to   quad f(U_t+1 U_t a_t) = 0 \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f defines the dynamics, implicitly, as constraints on the states and controls, U_1T and a_1T-1, which are both free variables in the solver. This optimization framework is called direct collocation.  For details of our implementation please see our award-winning paper Direct Collocation for Quantum Optimal Control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gist of the method is that the dynamics are given by the solution to the Schrodinger equation, which is results in unitary evolution given by exp(-i H(a_t)), where H(a_t) is the Hamiltonian of the system.  We can approximate this evolution using Pade approximants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nf(U_t+1 U_t a_t) = U_t+1 - exp(-i H(a_t)) U_t \napprox U_t+1 - B^-1(a_t) F(a_t) U_t \n= B(a_t) U_t+1 - F(a_t) U_t \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(a_t) and F(a_t) are the backward and forward Pade operators, and are just polynomials in H(a_t). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation is possible because direct collocation allows for the dynamics to be implicit. Since numerically calculating matrix exponentials inherently requires an approximation – the Padé approximant is commonly used – utilizing this formulation significantly improves performance, as, at least here, no matrix inversion is required.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"EditURL = \"../../../literate/man/utils.jl\"","category":"page"},{"location":"generated/man/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"generated/man/utils/#Gates","page":"Utilities","title":"Gates","text":"","category":"section"},{"location":"generated/man/utils/#States","page":"Utilities","title":"States","text":"","category":"section"},{"location":"generated/man/utils/#Operators","page":"Utilities","title":"Operators","text":"","category":"section"},{"location":"generated/man/utils/#Isomorphisms","page":"Utilities","title":"Isomorphisms","text":"","category":"section"},{"location":"generated/man/utils/#Measurements","page":"Utilities","title":"Measurements","text":"","category":"section"},{"location":"generated/man/utils/#Subspaces","page":"Utilities","title":"Subspaces","text":"","category":"section"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"generated/man/utils/","page":"Utilities","title":"Utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"We provide a number of problem templates for making it simple and easy to set up and solve certain types of quantum optimal control problems. These templates all construct a QuantumControlProblem object.  The problem templates are:","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem\nUnitaryMinimumTimeProblem","category":"page"},{"location":"generated/man/problem_templates/#Unitary-Smooth-Pulse-Problem","page":"Problem Templates","title":"Unitary Smooth Pulse Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"UnitarySmoothPulseProblem","category":"page"},{"location":"generated/man/problem_templates/#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","page":"Problem Templates","title":"QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem","text":"UnitarySmoothPulseProblem(H_drift, H_drives, U_goal, T, Δt; kwargs...)\nUnitarySmoothPulseProblem(system::QuantumSystem, U_goal, T, Δt; kwargs...)\n\nConstruct a QuantumControlProblem for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,\n\nbeginaligned\nundersetvectildeU a dota ddota Delta ttextminimize  quad\nQ cdot ellqty(vectildeU_T vectildeU_textgoal) + frac12 sum_t qty(R_a a_t^2 + R_dota dota_t^2 + R_ddota ddota_t^2) \ntext subject to   quad vbP^(n)qty(vectildeU_t+1 vectildeU_t a_t Delta t_t) = 0 \n a_t+1 - a_t - dota_t Delta t_t = 0 \n quad dota_t+1 - dota_t - ddota_t Delta t_t = 0 \n quad a_t leq a_textbound \n quad ddota_t leq ddota_textbound \n quad Delta t_textmin leq Delta t_t leq Delta t_textmax \nendaligned\n\nwhere, for U in SU(N),\n\nellqty(vectildeU_T vectildeU_textgoal) =\nabs1 - frac1N abs tr qty(U_textgoal U_T) \n\nis the infidelity objective function, Q is a weight, R_a, R_dota, and R_ddota are weights on the regularization terms, and vbP^(n) is the nth-order Pade integrator.\n\nArguments\n\nH_drift::AbstractMatrix{<:Number}: the drift hamiltonian\nH_drives::Vector{<:AbstractMatrix{<:Number}}: the control hamiltonians\n\nor\n\nsystem::QuantumSystem: the system to be controlled\n\nwith\n\nU_goal::AbstractMatrix{<:Number}: the target unitary\nT::Int: the number of timesteps\nΔt::Float64: the (initial) time step size\n\nKeyword Arguments\n\nfree_time::Bool=true: whether or not to allow the time steps to vary\ninit_trajectory::Union{NamedTrajectory, Nothing}=nothing: an initial trajectory to use\na_bound::Float64=1.0: the bound on the control pulse\na_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives)): the bounds on the control pulses, one for each drive\na_guess::Union{Matrix{Float64}, Nothing}=nothing: an initial guess for the control pulses\ndda_bound::Float64=1.0: the bound on the control pulse derivative\ndda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives)): the bounds on the control pulse derivatives, one for each drive\nΔt_min::Float64=0.5 * Δt: the minimum time step size\nΔt_max::Float64=1.5 * Δt: the maximum time step size\ndrive_derivative_σ::Float64=0.01: the standard deviation of the initial guess for the control pulse derivatives\nQ::Float64=100.0: the weight on the infidelity objective\nR=1e-2: the weight on the regularization terms\nR_a::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulses\nR_da::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse derivatives\nR_dda::Union{Float64, Vector{Float64}}=R: the weight on the regularization term for the control pulse second derivatives\nleakage_suppression::Bool=false: whether or not to suppress leakage to higher energy states\nleakage_indices::Union{Nothing, Vector{Int}}=nothing: the indices of vectildeU corresponding leakage operators that should be suppressed\nsystem_levels::Union{Nothing, Vector{Int}}=nothing: the number of levels in each subsystem\nR_leakage=1e-1: the weight on the leakage suppression term\nmax_iter::Int=1000: the maximum number of iterations for the solver\nlinear_solver::String=\"mumps\": the linear solver to use\nipopt_options::Options=Options(): the options for the Ipopt solver\nconstraints::Vector{<:AbstractConstraint}=AbstractConstraint[]: additional constraints to add to the problem\ntimesteps_all_equal::Bool=true: whether or not to enforce that all time steps are equal\nverbose::Bool=false: whether or not to print constructor output\nU_init::Union{AbstractMatrix{<:Number},Nothing}=nothing: an initial guess for the unitary\nintegrator=Integrators.fourth_order_pade: the integrator to use for the unitary\ngeodesic=true: whether or not to use the geodesic as the initial guess for the unitary\npade_order=4: the order of the Pade approximation to use for the unitary integrator\nautodiff=pade_order != 4: whether or not to use automatic differentiation for the unitary integrator\nsubspace=nothing: the subspace to use for the unitary integrator\njacobian_structure=true: whether or not to use the jacobian structure\nhessian_approximation=false: whether or not to use L-BFGS hessian approximation in Ipopt\nblas_multithreading=true: whether or not to use multithreading in BLAS\n\n\n\n\n\n","category":"function"},{"location":"generated/man/problem_templates/#Unitary-Minimum-Time-Problem","page":"Problem Templates","title":"Unitary Minimum Time Problem","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}

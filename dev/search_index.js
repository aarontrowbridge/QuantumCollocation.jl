var documenterSearchIndex = {"docs":
[{"location":"quantum_systems/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"section"},{"location":"quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Order = [:type, :method, :function]","category":"page"},{"location":"quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Modules = [QuantumSystems]","category":"page"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.AbstractSystem","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.AbstractSystem","text":"AbstractSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.QuantumSystem","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystemNew <: AbstractSystem\n\nA struct for storing the isomorphisms of the system's drift and drive Hamiltonians, as well as the system's parameters.\n\n\n\n\n\n","category":"type"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.QuantumSystem-Tuple{Matrix{<:Number}, Vector{<:Matrix{<:Number}}}","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::Matrix{<:Number},\n    H_drives::Vector{Matrix{<:Number}};\n    params=Dict{Symbol, Any}(),\n    kwargs...\n)::QuantumSystem\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"method"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.G-Tuple{AbstractMatrix{<:Number}}","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH:\n\nG(H) = widetilde- i H = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\n\n\n\n\n","category":"method"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.H-Tuple{AbstractMatrix{<:Number}}","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.H","text":"H(G::AbstractMatrix{<:Number})::Matrix{ComplexF64}\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H\n\n\n\n\n\n","category":"method"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.MultiModeSystem-Tuple{Int64, Int64}","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.MultiModeSystem","text":"MultiModeSystem(\n    transmon_levels::Int,\n    cavity_levels::Int;\n    χ=2π * -0.5459e-3,\n    κ=2π * 4e-6,\n    χGF=2π * -1.01540302914e-3,\n    α=-2π * 0.143,\n    n_cavities=1\n)::QuantumSystem\n\nCreate a new QuantumSystemNew object for a transmon qubit with transmon_levels levels coupled to a single cavity with cavity_levels levels.\n\nThe Hamiltonian for this system is given by\n\nhat H =\n    frackappa2 hata^ dagger hata left( hata^daggerhata-1right) +\n    2 chi dyade hata^daggerhata +\n    left(\n        epsilon_c(t) +\n        epsilon_q(t) +\n        mathrmcc\n    right)\n\n\n\n\n\n","category":"method"},{"location":"quantum_systems/#QuantumCollocation.QuantumSystems.lie_subalgebra_dim-Tuple{Vector{<:AbstractMatrix}}","page":"Quantum Systems","title":"QuantumCollocation.QuantumSystems.lie_subalgebra_dim","text":"lie_subalgebra_dim(Hs::Vector{<:AbstractMatrix})\n\nReturns the dimension of the Lie subalgebra generated by the operators in Hs.\n\n\n\n\n\n","category":"method"},{"location":"quantum_utils/#Quantum-Utilities","page":"Quantum Utilities","title":"Quantum Utilities","text":"","category":"section"},{"location":"quantum_utils/","page":"Quantum Utilities","title":"Quantum Utilities","text":"Modules = [QuantumUtils]","category":"page"},{"location":"generated/man/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"EditURL = \"../../../literate/man/quantum_systems.jl\"","category":"page"},{"location":"generated/man/quantum_systems/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"section"},{"location":"generated/man/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"page"},{"location":"generated/man/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"generated/man/quantum_utils/","page":"Quantum Utilities","title":"Quantum Utilities","text":"EditURL = \"../../../literate/man/quantum_utils.jl\"","category":"page"},{"location":"generated/man/quantum_utils/#QuantumUtils","page":"Quantum Utilities","title":"QuantumUtils","text":"","category":"section"},{"location":"generated/man/quantum_utils/","page":"Quantum Utilities","title":"Quantum Utilities","text":"","category":"page"},{"location":"generated/man/quantum_utils/","page":"Quantum Utilities","title":"Quantum Utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/single_qubit/","page":"Single Qubit","title":"Single Qubit","text":"EditURL = \"../../../literate/examples/single_qubit.jl\"","category":"page"},{"location":"generated/examples/single_qubit/#Single-Qubit","page":"Single Qubit","title":"Single Qubit","text":"","category":"section"},{"location":"generated/examples/single_qubit/","page":"Single Qubit","title":"Single Qubit","text":"","category":"page"},{"location":"generated/examples/single_qubit/","page":"Single Qubit","title":"Single Qubit","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"EditURL = \"../../literate/quickstart.jl\"","category":"page"},{"location":"generated/quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumCollocation","category":"page"},{"location":"#QuantumCollocation.jl","page":"Home","title":"QuantumCollocation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Direct Collocation for Quantum Optimal Control (arXiv)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In quantum optimal control, we are interested in finding a pulse sequence a_1T-1 to drive a quantum system and realize a target gate U_textgoal. We formulate this problem as a nonlinear program (NLP) of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nundersetU_1T a_1T-1textminimize  quad ell(U_T U_textgoal)\ntext subject to   quad f(U_t+1 U_t a_t) = 0 \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where f defines the dynamics, implicitly, as constraints on the states and controls, U_1T and a_1T-1, which are both free variables in the solver. This optimization framework is called direct collocation.  For details of our implementation please see our award-winning paper Direct Collocation for Quantum Optimal Control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The gist of the method is that the dynamics are given by the solution to the Schrodinger equation, which is results in unitary evolution given by exp(-i H(a_t)), where H(a_t) is the Hamiltonian of the system.  We can approximate this evolution using Pade approximants:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nf(U_t+1 U_t a_t) = U_t+1 - exp(-i H(a_t)) U_t \napprox U_t+1 - B^-1(a_t) F(a_t) U_t \n= B(a_t) U_t+1 - F(a_t) U_t \nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(a_t) and F(a_t) are the backward and forward Pade operators, and are just polynomials in H(a_t). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation is possible because direct collocation allows for the dynamics to be implicit. Since numerically calculating matrix exponentials inherently requires an approximation – the Padé approximant is commonly used – utilizing this formulation significantly improves performance, as, at least here, no matrix inversion is required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"EditURL = \"../../../literate/man/problem_templates.jl\"","category":"page"},{"location":"generated/man/problem_templates/#Problem-Templates","page":"Problem Templates","title":"Problem Templates","text":"","category":"section"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"","category":"page"},{"location":"generated/man/problem_templates/","page":"Problem Templates","title":"Problem Templates","text":"This page was generated using Literate.jl.","category":"page"}]
}
